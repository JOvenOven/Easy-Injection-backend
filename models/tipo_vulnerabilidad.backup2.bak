const Joi = require('joi');
const mongoose = require('mongoose');
const debug = require('debug')('easyinjection:models:vulntype');

// Schema de tipos de vulnerabilidad
const vulnerabilityTypeSchema = new mongoose.Schema({
    nombre: { 
        type: String, 
        enum: ['XSS', 'SQLi', 'CSRF', 'XXE', 'SSTI'], 
        required: true, 
        unique: true 
    },
    descripcion: { type: String, maxlength: 255 }
});

// Modelo de Mongoose
const VulnerabilityTypeModel = mongoose.models.VulnerabilityType || mongoose.model('VulnerabilityType', vulnerabilityTypeSchema);

/**
 * Clase de dominio VulnerabilityType con encapsulamiento OOP
 * Representa un tipo de vulnerabilidad de seguridad
 */
class VulnerabilityType {
    // Campos privados
    #nombre;
    #descripcion;
    #id;
    #version;

    /**
     * Constructor privado - usar factory methods
     * @private
     */
    constructor(data = {}) {
        const plainData = data && typeof data.toObject === 'function' ? data.toObject() : data;
        
        this.#nombre = plainData.nombre;
        this.#descripcion = plainData.descripcion;
        this.#id = plainData._id;
        this.#version = plainData.__v;
    }

    // Getters y Setters
    get nombre() {
        return this.#nombre;
    }

    set nombre(value) {
        const validValues = ['XSS', 'SQLi', 'CSRF', 'XXE', 'SSTI'];
        if (!validValues.includes(value)) {
            throw new Error(`Tipo de vulnerabilidad inválido. Debe ser uno de: ${validValues.join(', ')}`);
        }
        this.#nombre = value;
    }

    get descripcion() {
        return this.#descripcion;
    }

    set descripcion(value) {
        if (value && value.length > 255) {
            throw new Error('La descripción no puede exceder 255 caracteres');
        }
        this.#descripcion = value;
    }



    // Métodos de dominio
    /**
     * Obtiene el nombre completo del tipo de vulnerabilidad
     * @returns {string}
     */
    getFullName() {
        const fullNames = {
            'XSS': 'Cross-Site Scripting',
            'SQLi': 'SQL Injection',
            'CSRF': 'Cross-Site Request Forgery',
            'XXE': 'XML External Entity',
            'SSTI': 'Server-Side Template Injection'
        };
        return fullNames[this.#nombre] || this.#nombre;
    }

    /**
     * Verifica si es un tipo de inyección
     * @returns {boolean}
     */
    isInjectionType() {
        return ['SQLi', 'XSS', 'XXE', 'SSTI'].includes(this.#nombre);
    }

    /**
     * Obtiene categoría OWASP Top 10
     * @returns {string}
     */
    getOWASPCategory() {
        const categories = {
            'XSS': 'A03:2021 - Injection',
            'SQLi': 'A03:2021 - Injection',
            'CSRF': 'A01:2021 - Broken Access Control',
            'XXE': 'A05:2021 - Security Misconfiguration',
            'SSTI': 'A03:2021 - Injection'
        };
        return categories[this.#nombre] || 'Unknown';
    }

    /**
     * Obtiene severidad típica esperada
     * @returns {string}
     */
    getTypicalSeverity() {
        const severities = {
            'XSS': 'Media',
            'SQLi': 'Crítica',
            'CSRF': 'Media',
            'XXE': 'Alta',
            'SSTI': 'Crítica'
        };
        return severities[this.#nombre] || 'Media';
    }

    // Factory Methods
    /**
     * Crea una instancia desde un documento Mongoose
     * @param {Document} mongooseDoc - Documento de Mongoose
     * @returns {VulnerabilityType|null}
     */
    static fromMongoose(mongooseDoc) {
        if (!mongooseDoc) return null;
        debug('fromMongoose: converting Mongoose doc to VulnerabilityType');
        return new VulnerabilityType(mongooseDoc.toObject());
    }

    /**
     * Crea una instancia desde datos planos
     * @param {Object} data - Datos del tipo de vulnerabilidad
     * @returns {VulnerabilityType}
     */
    static build(data) {
        return new VulnerabilityType(data);
    }

    /**
     * Crea una instancia vacía con valores por defecto
     * @returns {VulnerabilityType}
     */
    static createEmpty() {
        return new VulnerabilityType({ nombre: 'XSS', descripcion: '' });
    }

    // Método estático de validación
    static validate(type) {
        const schema = Joi.object({
            nombre: Joi.string().valid('XSS', 'SQLi', 'CSRF', 'XXE', 'SSTI').required(),
            descripcion: Joi.string().max(255)
        });

        return schema.validate(type);
    }

    // Método de instancia para guardar
    async save() {
        if (this.#id) {
            debug('save: updating VulnerabilityType %s', this.#id);
            const updateData = this.toObject();
            delete updateData._id;
            delete updateData.__v;
            
            const updated = await VulnerabilityTypeModel.findByIdAndUpdate(
                this.#id,
                { $set: updateData },
                { new: true, runValidators: true }
            );
            
            if (!updated) {
                throw new Error(`VulnerabilityType with _id ${this.#id} not found`);
            }
            
            this.#id = updated._id;
            this.#version = updated.__v;
            return updated;
        } else {
            const doc = new VulnerabilityTypeModel(this.toObject());
            const saved = await doc.save();
            this.#id = saved._id;
            this.#version = saved.__v;
            return saved;
        }
    }

    // Exponer el modelo de Mongoose para queries complejas
    static get Model() {
        return VulnerabilityTypeModel;
    }

    // Métodos estáticos de consulta
    static async find(query = {}) {
        const docs = await VulnerabilityTypeModel.find(query);
        return docs.map(doc => VulnerabilityType.fromMongoose(doc));
    }

    static async findOne(query) {
        const doc = await VulnerabilityTypeModel.findOne(query);
        return VulnerabilityType.fromMongoose(doc);
    }

    static async findById(id) {
        const doc = await VulnerabilityTypeModel.findById(id);
        return VulnerabilityType.fromMongoose(doc);
    }

    static async findByIdAndUpdate(id, update, options = {}) {
        const doc = await VulnerabilityTypeModel.findByIdAndUpdate(id, update, { new: true, ...options });
        return VulnerabilityType.fromMongoose(doc);
    }

    static async findByIdAndDelete(id) {
        const doc = await VulnerabilityTypeModel.findByIdAndDelete(id);
        return VulnerabilityType.fromMongoose(doc);
    }

    static async create(data) {
        const doc = new VulnerabilityTypeModel(data);
        const saved = await doc.save();
        return VulnerabilityType.fromMongoose(saved);
    }

    // Método para convertir a objeto plano
    toObject() {
        const obj = {};
        if (this.#id !== undefined) obj._id = this.#id;
        if (this.#nombre !== undefined) obj.nombre = this.#nombre;
        if (this.#descripcion !== undefined) obj.descripcion = this.#descripcion;
        if (this.#version !== undefined) obj.__v = this.#version;
        return obj;
    }

    /**
     * Representación en string del tipo de vulnerabilidad
     * @returns {string}
     */
    toString() {
        return `[${this.#nombre}] ${this.getFullName()}: ${this.#descripcion || 'Sin descripción'}`;
    }
}

module.exports = VulnerabilityType;
